<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.units - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + a + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

<script src="/js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body onload="listanchors()" class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="/images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="d-programming-language.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="d-programming-language.org">Entire D  Site</option>
					<option value="d-programming-language.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul><li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul><li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul><li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_gregorian.html" title="Gregorian Calendar">std.gregorian</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_regexp.html" title="regular expressions (deprecated)">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="index.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="index.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="index.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="index.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul><li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul><li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>std.units</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/units.d -->
Type-based, i.e. statically checked, units of measurement.
<p></p>
A <i>quantity</i> is a wrapper struct around an arbitrary value type,
 parametrized with a certain unit. A <i>unit</i> is basically little more than
 a marker type to keep different kinds of quantities apart, but might
 additionally have an associated name and symbol string, and – more
 more importantly – define <i>conversions</i> to other units. While all
 of the possible conversions must be defined statically for type-checking,
 arbitrary callables are supported for actually converting the values, which
 do not necessarily need to be evauatable at compile time.
<p></p>

 Conversions only happen if explicitly requested and there is no different
 internal representation of values – for example <span class="d_inlinecode">1 * kilo(metre)</span> is
 stored just as 1 in memory, not as 1000 or relative to any other »canonical
 unit«.
<p></p>

 On top of the template core of the module, to which <a name="units"></a><span class="ddoc_psymbol">units</span> are types only,
 a layer making use of »dummy« unit instances with operators defined on them
 makes it possible to work with quantities and <a name="units"></a><span class="ddoc_psymbol">units</span> in a natural way, such
 that the actual unit types never need to be user directly in client code
 (see the example below).
<p></p>

 In the design of this module, the explicit concept of <i>dimensions</i> does
 not appear, because it would add a fair amount of complication to both the
 interface and the implementation for little benefit. Rather, the notion is
 established implicitly by defining conversions between pairs of units – to
 see if two units share the same dimension, just check for convertibility.
<p></p>

 The <span class="d_inlinecode">std.si</span> module defines SI prefixes and units for use with this
 module.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">enum</span> foo = baseUnit!(<span class="d_string">"foo"</span>, <span class="d_string">"f"</span>);
 <span class="d_keyword">enum</span> bar = scale!(foo, 21, <span class="d_string">"bar"</span>, <span class="d_string">"b"</span>);

 <span class="d_keyword">auto</span> a = 2 * bar;
 <span class="d_keyword">assert</span>(convert!foo(a) == 42 * foo);
</pre>

<p></p>
<b>Todo:</b><br>
<ul> <li>Integration with the rest of Phobos (<span class="d_inlinecode">std.datetime</span>, <span class="d_inlinecode">std.math</span>, …)</li>
  <li>Replace the proof-of-concept unit conversion implementation with an
   optimized one – currently some unneeded function calls are generated.</li>
  <li>For <span class="d_inlinecode">scale</span>/<span class="d_inlinecode">ScaledUnit</span>, use runtime rational/two longs
   instead of double conversion per default, to avoid precision issues?</li>
  <li>Benchmark quantity operations vs. plain value type operations.</li>
  <li>Make quantities of the same unit implicitly convertible if the value
   types are – e.g. via <span class="d_inlinecode">ImplicitConversionTargets</span> once multiple
   alias this statements are allowed.</li>
  <li>Are multiple conversion targets for a unit really needed? Disallowing
   that would remove some odd corner cases.</li>
  <li>Just forward <a href="#Quantity"><span class="d_inlinecode">Quantity</span></a> instanciations with unit
   <a href="#dimensionless"><span class="d_inlinecode">dimensionless</span></a> to the value type altogether to avoid the current
   limitations regarding <span class="d_inlinecode">alias this</span>?</li>
 </ul>

<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br><a href="http://klickverbot.at">David Nadlinger</a><p></p>

<dl><dt class="d_decl">template <a name="UnitImpl"></a><span class="ddoc_psymbol">UnitImpl</span>()</dt>
<dd>Mixin template containing the implementation of the unit instance operators.
<p></p>
Furthermore, it marks the surrounding type as unit – every unit type has to
 mixin this template.
<p></p>

 In addition, a unit type might also define a toString() function returning
 a custom unit symbol/name, and a list of <a href="#Conversion"><span class="d_inlinecode">Conversion</span></a>s. The example
 shows how a unit type for inches might be defined if <a href="#scale"><span class="d_inlinecode">scale</span></a> and
 <a href="#ScaledUnit"><span class="d_inlinecode">ScaledUnit</span></a> did not exist (which remove the need to write
 boilerplate code like this).

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">struct</span> Inch {
     <span class="d_keyword">mixin</span> <span class="d_psymbol">UnitImpl</span>;

     <span class="d_keyword">static</span> string toString(UnitString type = UnitString.name) {
         <span class="d_keyword">final</span> <span class="d_keyword">switch</span> (type) {
             <span class="d_keyword">case</span> UnitString.name: <span class="d_keyword">return</span> <span class="d_string">"inch"</span>;
             <span class="d_keyword">case</span> UnitString.symbol: <span class="d_keyword">return</span> <span class="d_string">"in"</span>;
         }
     }

     <span class="d_keyword">alias</span> TypeTuple!(
         Conversion!(centi(metre), toCm, fromCm)
     ) Conversions;

     <span class="d_keyword">static</span> V toCm(V)(V v) {
         <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(V)(v * 2.54);
     }
     <span class="d_keyword">static</span> V fromCm(V)(V v) {
         <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(V)(v / 2.54);
     }
 }
 <span class="d_keyword">enum</span> inch = Inch.init; <span class="d_comment">// Unit instance to use with abbreviated syntax.
</span></pre>

<p></p>
<b>Note:</b><br>
Two existing units <span class="d_inlinecode">a</span> and <span class="d_inlinecode">c</span> can't be retroactively extended
 with a direct conversion between them. This is by design, as it would break
 D's modularization/encapsulation approach (alternative: use mixin template
 for defining conversion functions, then it would be possible to have
 different behavior of the conversion function in each module). However,
 currently it <i>is</i> possible to create a third unit <span class="d_inlinecode">b</span> which is
 convertible to both <span class="d_inlinecode">a</span> and <span class="d_inlinecode">c</span>, and then perform the conversion in
 two steps: <span class="d_inlinecode">convert!c(convert!b(1 * a))</span>)<p></p>

<dl><dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "*", Rhs)(Rhs <i>rhs</i>);
<br>auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "/", Rhs)(Rhs <i>rhs</i>);
</dt>
<dd>Multiplication/division of two unit instances, yielding a unit instance
 representing the product/quotient unit.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">enum</span> joule = newton * metre;
 <span class="d_keyword">enum</span> watt = joule / second;
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "*", V)(V <i>rhs</i>);
<br>auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "/", V)(V <i>rhs</i>);
<br>auto <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op : "*", V)(V <i>lhs</i>);
<br>auto <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op : "/", V)(V <i>lhs</i>);
</dt>
<dd>Multiplication/division of an unit and a value type, constructing a
 Quantity instance.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> a = 2 * metre;
 <span class="d_keyword">auto</span> b = 2 / metre;
 <span class="d_keyword">auto</span> c = metre * 2;
 <span class="d_keyword">auto</span> d = metre / 2;
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="UnitString"></a><span class="ddoc_psymbol">UnitString</span>;
</dt>
<dd>Possible string representations of units.<p></p>

<dl><dt class="d_decl"><a name="name"></a><span class="ddoc_psymbol">name</span></dt>
<dd>Use full unit names when constructing strings.<p></p>

</dd>
<dt class="d_decl"><a name="symbol"></a><span class="ddoc_psymbol">symbol</span></dt>
<dd>Use unit symbols when constructing strings.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="BaseUnit"></a><span class="ddoc_psymbol">BaseUnit</span>(string name,string symbol = null);
<br>template <a name="baseUnit"></a><span class="ddoc_psymbol">baseUnit</span>(string name,string symbol = null)</dt>
<dd>Shordhand for creating a basic unit with a name and a symbol, and no
 conversions defined.
<p></p>
When using <a name="BaseUnit"></a><span class="ddoc_psymbol">BaseUnit</span>, in virtually every use case, you also want to define
 an associated unit instance, as shown below. As there should be no real use
 for the unit type in user case anyway, you can also use baseUnit which
 directly returns a unit instance.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">alias</span> <span class="d_psymbol">BaseUnit</span>!(<span class="d_string">"Ampere"</span>, <span class="d_string">"A"</span>) Ampere;
 <span class="d_keyword">enum</span> ampere = Ampere.init;
 <span class="d_comment">// or
</span> <span class="d_keyword">enum</span> ampere = baseUnit!(<span class="d_string">"Ampere"</span>, <span class="d_string">"A"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="Dimensionless"></a><span class="ddoc_psymbol">Dimensionless</span>;
<br>Dimensionless <a name="dimensionless"></a><span class="ddoc_psymbol">dimensionless</span>;
</dt>
<dd>A special unit used to represent dimensionless quantities.<p></p>

</dd>
<dt class="d_decl">struct <a name="BaseUnitExp"></a><span class="ddoc_psymbol">BaseUnitExp</span>(B,R) if (!isDerivedUnit!(B) &amp;&amp; isUnit!(B) &amp;&amp; isRational!(R));
</dt>
<dd>A pair of a (base) unit and a compile-time rational exponent.
<p></p>
Multiple BaseUnitExps make up a <a href="#DerivedUnit"><span class="d_inlinecode">DerivedUnit</span></a>.<p></p>

</dd>
<dt class="d_decl">template <a name="DerivedUnit"></a><span class="ddoc_psymbol">DerivedUnit</span>(T...) if (allSatisfy!(isBaseUnitExp,T))<br>struct <a name="DUnit"></a><span class="ddoc_psymbol">DUnit</span>(T...);
</dt>
<dd>Constructs a derived unit, consisting of a number of base units and
 associated exponents.
<p></p>
Usually, constructing unit types using the operators defined on the unit
 instances is preferred over using this template directly.
<p></p>

 Internally, derived units are represented as DUnit instances, but never try
 to use it directly – the <a name="DerivedUnit"></a><span class="ddoc_psymbol">DerivedUnit</span> template performs canonicalization to
 ensure that semantically equivalent units share the same underlying types.
 Also, the result will not actually be a DUnit in some cases, but rather
 Dimensionless or a single base unit without exponent.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">alias</span> <span class="d_psymbol">DerivedUnit</span>!(
     BaseUnitExp!(Ampere, Rational!1),
     BaseUnitExp!(Second, Rational!1)
 ) Coulomb;
 <span class="d_keyword">enum</span> coulomb = Coulomb.init;

 <span class="d_comment">// In most cases, you would want to just use the operators
</span> <span class="d_comment">// on the unit instances instead:
</span> <span class="d_keyword">enum</span> coulomb = ampere * second;
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="AffineUnit"></a><span class="ddoc_psymbol">AffineUnit</span>(BaseUnit,alias toBaseOffset,string name,string symbol = null) if (isUnit!(BaseUnit));
<br>template <a name="AffineUnit"></a><span class="ddoc_psymbol">AffineUnit</span>(alias baseUnit,alias toBaseOffset,string name,string symbol = null) if (isUnitInstance!(baseUnit))<br>auto <a name="affine"></a><span class="ddoc_psymbol">affine</span>(alias toBaseOffset, string name, string symbol = null, U)(U <i>u</i>);
</dt>
<dd>An affine unit – the most common case being a unit that is related to other
 units representing the same physical quantity not by a scale factor, but by
 a shift in the zero point.
<p></p>
This is not a fundamentally new concept, adding a constant offset could
 just be implemented in a custom conversion function as well (see the
 <a href="#UnitImpl"><span class="d_inlinecode">UnitImpl</span></a> documentation). However, Quantity is specialized on
 affine units such as to only provide operations which make sense for them:
<p></p>

 Informally speaking, an affine space is a vector space which »forgot« its
 origin, its elements are points, not vectors. Thus, a quantity of an
 affine unit cannot be added to another (as it makes no sense to add two
 points), but like vectors can be added to points to yield a new point, a
 quantity of the underlying base unit can be. Also, two affine quantities
 can be substracted to yield a quantity of the base unit (just as two
 points can be substracted to get a vector pointing from one to another).
<p></p>

 The most common example for this are units of temperature like degrees
 Celsius or Fahrenheit, as demonstrated below.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">enum</span> celsius = affine!(273.15, <span class="d_string">"degrees Celsius"</span>, <span class="d_string">"°C"</span>)(kelvin);
 <span class="d_keyword">auto</span> t = 3.0 * celsius;
 t += 1.0 * kelvin; <span class="d_comment">// adding Kelvin is okay
</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, t += 2.0 * celsius)); <span class="d_comment">// adding Celsius is not
</span> writeln(t - 0.0 * celsius); <span class="d_comment">// 4 Kelvin, not degrees Celsius
</span></pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="Quantity"></a><span class="ddoc_psymbol">Quantity</span>(Unit,ValueType = double) if (isUnit!(Unit));
<br>template <a name="Quantity"></a><span class="ddoc_psymbol">Quantity</span>(alias unit,ValueType = double) if (isUnitInstance!(unit))</dt>
<dd>A quantity consisting of a value and an associated unit of measurement.
<p></p>
The unary plus, unary minus, addition, subtraction, multiplication,
 division, comparison, increment and decrement operators are forwarded to
 the underlying value type, if the operation is meaningful for the given
 unit(s).
<p></p>

 A quantity is only implicitly convertible to the underlying value type
 (via <span class="d_inlinecode">alias this</span>) if it is dimensionless – divide a quantity by its
 unit if you want to access the raw value.<p></p>

<dl><dt class="d_decl">this(OtherV)(Quantity!(Unit,OtherV) <i>other</i>);
<br>Quantity <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(OtherV)(Quantity!(Unit,OtherV) <i>other</i>);
</dt>
<dd>Two quantites of the same unit are implicitely convertible on
 assignment if the underlying value types are.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> Quantity!(metre, <span class="d_keyword">float</span>) a = 2 * metre;
</pre>
<p></p>

</dd>
<dt class="d_decl">Quantity!(Unit,NewV) <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : Quantity!(Unit,NewV), NewV)();
</dt>
<dd>A quantity is castable to another one with the same unit if the value
 type can be casted to the new one.
<p></p>
For converting a quantity to another unit, see <a href="#convert"><span class="d_inlinecode">convert</span></a> instead.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> a = 2.0 * metre;
 <span class="d_keyword">assert</span>(<span class="d_keyword">cast</span>(Quantity!(metre, <span class="d_keyword">int</span>))a == 2 * metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opUnary"></a><span class="ddoc_psymbol">opUnary</span>(string op)();
</dt>
<dd>Unary plus/minus operators.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> l = 6 * metre;
 <span class="d_keyword">assert</span>(+l == 6 * metre);
 <span class="d_keyword">assert</span>(-l == (-6) * metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opUnary"></a><span class="ddoc_psymbol">opUnary</span>(string op)();
</dt>
<dd>Prefix increment/decrement operators.
<p></p>
They are only provided dimensionless quantities, because they are
 semantically equivalent to adding the dimensionless quantity 1.<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, RhsV)(Quantity!(Unit,RhsV) <i>rhs</i>);
<br>Quantity <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, RhsV)(Quantity!(Unit,RhsV) <i>rhs</i>);
</dt>
<dd>Addition/substraction of a quantity with the same unit.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> a = 3 * metre;
 <span class="d_keyword">auto</span> b = 2 * metre;
 <span class="d_keyword">assert</span>(a + b == 5 * metre);
 a -= b;
 <span class="d_keyword">assert</span>(a == 1 * metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, T)(T <i>rhs</i>);
<br>auto <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op, T)(T <i>lhs</i>);
<br>Quantity <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, T)(T <i>rhs</i>);
</dt>
<dd>Multplication/division by a plain value (i.e. a dimensionless quantity
 not represented by a Quantity instance).
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> l = 6 * metre;
 <span class="d_keyword">assert</span>(l * 2 == 12 * metre);
 l /= 2;
 <span class="d_keyword">assert</span>(l == 3 * metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "*", Rhs)(Rhs <i>rhs</i>);
<br>auto <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op : "*", Lhs)(Lhs <i>lhs</i>);
</dt>
<dd>Multiplication with a unit instance.
<p></p>
Returns a quantity with the same value, but the new unit.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> l = 6 * metre;
 <span class="d_keyword">assert</span>(l * metre == 6 * pow!2(metre));
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "/", RhsU)(RhsU <i>rhs</i>);
<br>auto <a name="opBinaryRight"></a><span class="ddoc_psymbol">opBinaryRight</span>(string op : "/", Lhs)(Lhs <i>rhs</i>);
</dt>
<dd>Division by a unit instance.
<p></p>
Returns a quantity with the same value, but the new unit.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> l = 6 * metre;
 <span class="d_keyword">assert</span>(l / metre == 6 * dimensionless);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "*", RhsU, RhsV)(Quantity!(RhsU,RhsV) <i>rhs</i>);
</dt>
<dd>Multiplication with another quantity.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> w = 3 * metre;
 <span class="d_keyword">auto</span> h = 2 * metre;
 <span class="d_keyword">assert</span>(w * h == 12 * pow!2(metre));
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op : "/", RhsU, RhsV)(Quantity!(RhsU,RhsV) <i>rhs</i>);
</dt>
<dd>Division by another quantity.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> s = 6 * metre;
 <span class="d_keyword">auto</span> t = 2 * second;
 <span class="d_keyword">assert</span>(s / t == 3 * metre / second);
</pre>
<p></p>

</dd>
<dt class="d_decl">int <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(RhsV)(Quantity!(Unit,RhsV) <i>rhs</i>);
<br>auto <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span>(RhsV)(Quantity!(Unit,RhsV) <i>rhs</i>);
</dt>
<dd>Comparison with another quantity of the same unit.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> a = 3 * metre;
 <span class="d_keyword">auto</span> b = 4 * metre;
 <span class="d_keyword">auto</span> c = 5 * second;
 <span class="d_keyword">assert</span>(a != b);
 <span class="d_keyword">assert</span>(a &lt; b);
 <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, a != c));
 <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, a &lt; c));
</pre>
<p></p>

</dd>
<dt class="d_decl">string <a name="toString"></a><span class="ddoc_psymbol">toString</span>(UnitString <i>type</i> = UnitString.name);
</dt>
<dd>Returns a string representation of the quantity, consisting of the
 value and a unit symbol or name.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> l = 6 * metre / second;
 <span class="d_keyword">assert</span>(l.<span class="d_psymbol">toString</span>() == <span class="d_string">"6 metre second^(-1)"</span>);
 <span class="d_keyword">assert</span>(l.<span class="d_psymbol">toString</span>(UnitString.symbol) == <span class="d_string">"6 m s^(-1)"</span>);
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">auto <a name="pow"></a><span class="ddoc_psymbol">pow</span>(Exp, U)(U <i>u</i>);
<br>auto <a name="pow"></a><span class="ddoc_psymbol">pow</span>(int numerator, uint denominator = 1<i>u</i>, U)(U <i>u</i>);
</dt>
<dd>Raises a unit instance to a given power.
<p></p>
Because the exponent must be known at compile-time (as the type of the
 result depends on it), overloading the ^^ operator for units.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">enum</span> squareMetre = <span class="d_psymbol">pow</span>!2(metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">auto <a name="pow"></a><span class="ddoc_psymbol">pow</span>(Exp, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
<br>auto <a name="pow"></a><span class="ddoc_psymbol">pow</span>(int numerator, uint denominator = 1u, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
</dt>
<dd>Raises a quantity to a given power.
<p></p>
Because the exponent must be known at compile-time (to determine the unit
 of the result), overloading the ^^ operator for quantities is not possible.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">auto</span> area = <span class="d_psymbol">pow</span>!2(5 * metre);
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="Conversion"></a><span class="ddoc_psymbol">Conversion</span>(T,alias R,alias I) if (isUnit!(T));
<br>template <a name="Conversion"></a><span class="ddoc_psymbol">Conversion</span>(alias t,alias R,alias I) if (isUnitInstance!(t))</dt>
<dd>A conversion »link« to a target unit, consisting of a callable converting
 a value to the target, and one for converting it back.
<p></p>
Is used in the optional Conversions property of base units, see the
 documentation for <a href="#UnitImpl"><span class="d_inlinecode">UnitImpl</span></a>.<p></p>

</dd>
<dt class="d_decl">auto <a name="convert"></a><span class="ddoc_psymbol">convert</span>(TargetUnit, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
<br>auto <a name="convert"></a><span class="ddoc_psymbol">convert</span>(alias targetUnit, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
</dt>
<dd>Converts a quantity to another unit.
<p></p>
The value type of the resulting quantity will be the same as the original
 one.

<p></p>
<b>Examples:</b><br><pre class="d_code"> writeln(<span class="d_psymbol">convert</span>!gram(2 * kilogram));
 writeln(<span class="d_psymbol">convert</span>!kilogram(2000 * gram));
 writeln(<span class="d_psymbol">convert</span>!(milli(newton))(2 * newton));
 writeln(<span class="d_psymbol">convert</span>!(kilo(newton))(2000000 * gram * meter / pow!2(second)));
 writeln(<span class="d_psymbol">convert</span>!(micro(newton) / pow!2(milli(metre)))(1234.0 * pascal));
</pre>
<p></p>

</dd>
<dt class="d_decl">bool <a name="canConvert"></a><span class="ddoc_psymbol">canConvert</span>(TargetUnit, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
<br>bool <a name="canConvert"></a><span class="ddoc_psymbol">canConvert</span>(alias targetUnit, Q : Quantity!(U,V), U, V)(Q <i>q</i>);
</dt>
<dd>Checks whether a quantity is convertible to a certain unit.
<p></p>
<b>Examples:</b><br><pre class="d_code"> <span class="d_keyword">assert</span>(<span class="d_psymbol">canConvert</span>!gram(2 * kilogram));
 <span class="d_keyword">assert</span>(!<span class="d_psymbol">canConvert</span>!metre(2 * kilogram));
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="ScaledUnit"></a><span class="ddoc_psymbol">ScaledUnit</span>(BaseUnit,alias toBaseFactor,string name,string symbol = null) if (isUnit!(BaseUnit));
<br>template <a name="ScaledUnit"></a><span class="ddoc_psymbol">ScaledUnit</span>(alias baseUnit,alias toBaseFactor,string name,string symbol = null) if (isUnitInstance!(baseUnit))<br>template <a name="scale"></a><span class="ddoc_psymbol">scale</span>(alias baseUnit,alias toBaseFactor,string name,string symbol = null) if (isUnitInstance!(baseUnit))</dt>
<dd>Shorthands for defining base units with a single conversion factor to
 another base unit.
<p></p>
The conversion is done by simply multiplying/dividing the value by the
 passed factor, which thus has to be defined for all value types this scaled
 unit is used with.
<p></p>

 Note that a generic alias is accepted as scaling factor, which makes it
 possible to use runtime values as scale factors without writing a custom
 unit type.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_comment">// The following three lines define the same unit. Most of the time, the
</span> <span class="d_comment">// third syntax is the preferred one because it directly declares a unit
</span> <span class="d_comment">// instance.
</span> <span class="d_keyword">alias</span> <span class="d_psymbol">ScaledUnit</span>!(Metre, 0.0254, <span class="d_string">"inch"</span>, <span class="d_string">"in"</span>) Inch;
 <span class="d_keyword">alias</span> <span class="d_psymbol">ScaledUnit</span>!(metre, 0.0254, <span class="d_string">"inch"</span>, <span class="d_string">"in"</span>) Inch;
 <span class="d_keyword">enum</span> inch = scale!(metre, 0.0254, <span class="d_string">"inch"</span>, <span class="d_string">"in"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl">struct <a name="PrefixedUnit"></a><span class="ddoc_psymbol">PrefixedUnit</span>(BaseUnit,int exponent,alias System) if (isUnit!(BaseUnit) &amp;&amp; !(isPrefixedUnit!(BaseUnit) &amp;&amp; BaseUnit.prefixBase == System.base));
<br>template <a name="PrefixedUnit"></a><span class="ddoc_psymbol">PrefixedUnit</span>(BaseUnit,int exponent,alias System) if (isPrefixedUnit!(BaseUnit) &amp;&amp; BaseUnit.prefixBase == System.base)<br>template <a name="PrefixedUnit"></a><span class="ddoc_psymbol">PrefixedUnit</span>(alias baseUnit,int exponent,alias System) if (isUnitInstance!(baseUnit))</dt>
<dd>A unit with a scaling prefix applied, e.g. <span class="d_inlinecode">kilo(metre)</span>.
<p></p>
There is conceptually no difference between defining a regular conversion
 and prefixing a unit. However, <a name="PrefixedUnit"></a><span class="ddoc_psymbol">PrefixedUnit</span> automatically generates the
 name of the new unit, and it is able to fold multiple prefixes of the same
 system, e.g. <span class="d_inlinecode">milli(kilo(metre))</span> to just <span class="d_inlinecode">metre</span>.<p></p>

</dd>
<dt class="d_decl">struct <a name="Prefix"></a><span class="ddoc_psymbol">Prefix</span>;
</dt>
<dd>A named prefix, part of a <a href="#PrefixSystem"><span class="d_inlinecode">PrefixSystem</span></a>.<p></p>

<dl><dt class="d_decl">int <a name="exponent"></a><span class="ddoc_psymbol">exponent</span>;
</dt>
<dd>The power the prefix represents.<p></p>

</dd>
<dt class="d_decl">string <a name="name"></a><span class="ddoc_psymbol">name</span>;
</dt>
<dd>The <a name="name"></a><span class="ddoc_psymbol">name</span> of the prefix, prepended to unit names.<p></p>

</dd>
<dt class="d_decl">string <a name="symbol"></a><span class="ddoc_psymbol">symbol</span>;
</dt>
<dd>The <a name="symbol"></a><span class="ddoc_psymbol">symbol</span> of the prefix, prepended to unit symbols.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">template <a name="PrefixSystem"></a><span class="ddoc_psymbol">PrefixSystem</span>(long systemBase,alias getPrefixes) if (is(typeof(getPrefixes()) : Prefix[]))</dt>
<dd>A prefix system, used with <a href="#PrefixedUnit"><span class="d_inlinecode">PrefixedUnit</span></a>.
<p></p>
Use the <a href="#DefinePrefixSystem"><span class="d_inlinecode">DefinePrefixSystem</span></a> mixin to automatically generate a helper
 function like <span class="d_inlinecode">kilo()</span> for every prefix in the system.
<p></p>

 <span class="d_inlinecode">getPrefixes</span> has to be a parameterless callable returning
 <a href="#Prefix"><span class="d_inlinecode">Prefix</span></a>[]. This scheme is used (instead of directly passing the
 prefix array as a parameter) to reduce code bloat, because delegate
 literals are mangled much shorter than array literals. The effect on the
 binary size is quite strong because the mangled name of a <a name="PrefixSystem"></a><span class="ddoc_psymbol">PrefixSystem</span>
 instance is part of every symbol in which a PrefixedUnit is involved.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">alias</span> <span class="d_psymbol">PrefixSystem</span>!(10, { <span class="d_keyword">return</span> [
     Prefix(-3, <span class="d_string">"milli"</span>, <span class="d_string">"m"</span>),
     Prefix(3, <span class="d_string">"kilo"</span>, <span class="d_string">"k"</span>)
 ]; }) System;
</pre>
<p></p>

</dd>
<dt class="d_decl">template <a name="prefixTemplate"></a><span class="ddoc_psymbol">prefixTemplate</span>(int exponent,alias System)</dt>
<dd>Shorthand for defining prefix templates like <span class="d_inlinecode">kilo!()</span>.
<p></p>
The created template, accessible via the result property, takes a unit
 instance and applies a prefix from the given list of prefixes to it.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">alias</span> PrefixSystem!(10, { <span class="d_keyword">return</span> [
     Prefix(-3, <span class="d_string">"milli"</span>, <span class="d_string">"m"</span>),
     Prefix(3, <span class="d_string">"kilo"</span>, <span class="d_string">"k"</span>)
 ]; }) System;
 <span class="d_keyword">alias</span> <span class="d_psymbol">prefixTemplate</span>!(-3, System) milli;
 <span class="d_keyword">alias</span> <span class="d_psymbol">prefixTemplate</span>!(3, System) kilo;
 <span class="d_comment">// Use the templates like this: milli!metre, kilo!metre, etc.
</span></pre>
<p></p>

</dd>
<dt class="d_decl">template <a name="DefinePrefixSystem"></a><span class="ddoc_psymbol">DefinePrefixSystem</span>(alias System)</dt>
<dd>Mixin template for creating prefix functions for all the prefixes in a
 prefix system. See <a href="#PrefixedUnit"><span class="d_inlinecode">PrefixedUnit</span></a> and <a href="#prefixTemplate"><span class="d_inlinecode">prefixTemplate</span></a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"> <span class="d_keyword">mixin</span> <span class="d_psymbol">DefinePrefixSystem</span>!(PrefixSystem!(10, { <span class="d_keyword">return</span> [
     Prefix(-3, <span class="d_string">"milli"</span>, <span class="d_string">"m"</span>),
     Prefix(3, <span class="d_string">"kilo"</span>, <span class="d_string">"k"</span>)
 ]; });
 <span class="d_comment">// Use milli!() and kilo!() as usual.
</span></pre>
<p></p>

</dd>
<dt class="d_decl">template <a name="Rational"></a><span class="ddoc_psymbol">Rational</span>(int n,uint d = 1u)</dt>
<dd>A compile-time rational number.
<p></p>
If you explicitely specify the denominator, be sure to use an *unsigned*
 integer literal (e.g. 2u) – even though the template accepts only unsigned
 integers anyway, this seems to make a difference.

<p></p>
<b>Note:</b><br>
This was tailored to the specific needs of the units library, and
 isn't optimized at all.<p></p>

</dd>
<dt class="d_decl">template <a name="Sum"></a><span class="ddoc_psymbol">Sum</span>(Lhs,Rhs) if (isRational!(Lhs) &amp;&amp; isRational!(Rhs))</dt>
<dd>The sum of two compile-time rational numbers.<p></p>

</dd>
<dt class="d_decl">template <a name="Difference"></a><span class="ddoc_psymbol">Difference</span>(Lhs,Rhs) if (isRational!(Lhs) &amp;&amp; isRational!(Rhs))</dt>
<dd>The difference between two compile-time rational numbers.<p></p>

</dd>
<dt class="d_decl">template <a name="Product"></a><span class="ddoc_psymbol">Product</span>(Lhs,Rhs) if (isRational!(Lhs) &amp;&amp; isRational!(Rhs))</dt>
<dd>The product of two compile-time rational numbers.<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>


<div id="copyright">
Copyright &copy; 1999-2011 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
