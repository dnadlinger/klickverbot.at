<!doctype html> <html lang=en> <head> <meta charset=utf-8> <link rel=stylesheet href='/css/250adbc.css'> <title>Testing Verilog AXI4-Lite Peripherals | David Nadlinger</title> <meta name=viewport content="width=device-width; initial-scale=1.0"> <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script> <link rel="openid.server" href="http://openid.klickverbot.at/"/> <link rel="openid2.provider" href="http://openid.klickverbot.at/"/> </head> <body> <header id=main_header> <h1><span><a href="/">David Nadlinger</a></span></h1> <nav role=navigation> <ul> <li><a href="/blog">Blog</a></li> <li><a href="/code">Code</a></li> <li><a href="/about">About</a></li> </ul> </nav> </header> <div role=main id=main_content> <article class=blog-post> <header> <h1><a href="/blog/2016/01/testing-verilog-axi4-lite-peripherals/">Testing Verilog AXI4-Lite Peripherals</a></h1> <section class=metadata> on <time datetime="2016-01-30T00:00:00-05:00">30 Jan 2016</time> </section> <ul class=pagenav> <li><a href="/blog/2013/05/the-state-of-ldc-on-windows/">Older</a></li> <li><a href="/blog/2018/02/photographing-a-single-atom/">Newer</a></li> </ul> </header> <div class=content> <p class=lead>Chips that combine one or more processor cores and FPGA fabric into one integrated system have become quite popular recently, the most well-known product being Xilinx’ ARM-based <a href="http://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html"><em>Zynq</em></a> series. The standardized AXI buses connecting them make it trivial to bring custom IP cores into the processor address space. This post describes how to interface with it from a standalone Verilog test-bench.</p> <p>The popularity these combined systems-on-a-chip have been enjoying lately in research labs is certainly in part due to the ease in which programmable logic can be connected to the CPU cores, as compared to having to design and implement an interface between a discrete ARM processor and a stand-alone FPGA chip. This is due to the fact that the Zynq chips feature several internal interconnects between the ARM cores and the programmable logic fabric (including access to the DDR system memory and cache coherency control). These buses follow ARM’s open AMBA AXI4 standard, which is available in several flavors: the base <em>AXI4</em> protocol, which defines a high-performance memory-mapped interface, <em>AXI4-Stream</em>, which realizes a unidirectional data flow with handshaking, and <em>AXI4-Lite</em>, which is similar to AXI4 but lacks advanced features like buffering, multiple widths and bursts. Each given device implementing one of these protocols can act as either a master or a slave.</p> <p>Here, we will concern ourselves only with perhaps the simplest case, an AXI4-Lite slave. A typical example for this would be a low-bandwidth control channel from the ARM CPU to a custom IP core. Implementing such a device is quite easy as the Xilinx development environment includes tooling to generate the code for interfacing with the AXI bus (although it seems that, compared to the average programmer, FPGA designers lack any sensibility for writing <em>pretty</em> or even just consistently formatted code). But of course, this leaves the question of how to verify that the IP core reacts correctly to these commands – as it is usually the case for HDL design, you certainly don’t want to run the time-consuming synthesis process and re-flash the hardware on every iteration in the debugging process, only to then find yourself in an environment where it is hard to diagnose errors anyway unless you had enough foresight to litter the code with ChipScope debug probes in all the right places.</p> <p>These days, I use <a href="http://iverilog.icarus.com/">Icarus Verilog</a> for most all of my simulation needs, except when some proprietary IP is involved for which no functional model is available outside the vendor tools. It is an open source project that provides a Verilog parser, optimizer and virtual machine, and together with a waveform viewer such as <a href=xxx>GtkWave</a> makes for a nice light-weight testing environment. For small-ish projects, it tends to have already finished the simulation before the clunky and bug-ridden vendor tools such as Xilinx <em>isim</em> would have even completed starting up.</p> <p>Co-simulating the code to run on the ARM CPU and the FPGA design is certainly possible – maybe by using Verilator and piping data flow on the AXI buses back and forth between the domains, or by bringing out the “big guns”, i.e. system-level verification tools made by companies like Cadence. The most straightforward solution, however, is certainly to test the core in question in isolation, while just manually handling the necessary AXI communication in the test-bench.</p> <p>Owing to the simplicity of the AXI4-Lite protocol, such functionality is not hard to implement. The “AMBA® AXI™ and ACE™ Protocol Specification” – available on the ARM website after logging in, and certainly floating around in other places as well – is quite clear and well-written. Interestingly, however, none of the templates provided by Xilinx seem to include the relevant pieces of HDL. So, without further ado, here is a Verilog task that reads a single word from the bus and compares it to the expected value:</p> <figure class=code> <div class=highlight><pre><span class="k">task</span> <span class="k">automatic</span> <span class="n">enforce_axi_read</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="no">C_S_AXI_ADDR_WIDTH</span> <span class="o">-</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="no">C_S_AXI_DATA_WIDTH</span> <span class="o">-</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">]</span> <span class="n">expected_data</span><span class="p">;</span>
  <span class="k">begin</span>
    <span class="n">s_axi_araddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">s_axi_arvalid</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
    <span class="n">s_axi_rready</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
    <span class="k">wait</span><span class="p">(</span><span class="n">s_axi_arready</span><span class="p">);</span>
    <span class="k">wait</span><span class="p">(</span><span class="n">s_axi_rvalid</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s_axi_rdata</span> <span class="o">!=</span> <span class="n">expected_data</span><span class="p">)</span> <span class="k">begin</span>
      <span class="nb">$display</span><span class="p">(</span><span class="s">&quot;Error: Mismatch in AXI4 read at %x: &quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
        <span class="s">&quot;expected %x, received %x&quot;</span><span class="p">,</span>
        <span class="n">expected_data</span><span class="p">,</span> <span class="n">s_axi_rdata</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="p">@(</span><span class="k">posedge</span> <span class="n">s_axi_aclk</span><span class="p">)</span> <span class="p">#</span><span class="mh">1</span><span class="p">;</span>
    <span class="n">s_axi_arvalid</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
    <span class="n">s_axi_rready</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endtask</span>
</pre></div><figcaption><span>Reading a word from the AXI4-Lite bus and comparing it to an expected result. </span></figcaption> </figure> <p>All the <code>s_axi_…</code> signals are supposed to be hooked up to the corresponding ports of the unit under tests, as they would be in an auto-generated test-bench module. To use it, simply insert <code>enforce_axi_read(&lt;addr&gt;, &lt;data&gt;);</code> at the appropriate point in your test sequence.</p> <p>In the same vein, the following task writes a data word to the given address:</p> <figure class=code> <div class=highlight><pre><span class="k">task</span> <span class="k">automatic</span> <span class="n">axi_write</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="no">C_S_AXI_ADDR_WIDTH</span> <span class="o">-</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">;</span>
  <span class="k">input</span> <span class="p">[</span><span class="no">C_S_AXI_DATA_WIDTH</span> <span class="o">-</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
  <span class="k">begin</span>
    <span class="n">s_axi_wdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">s_axi_awaddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">s_axi_awvalid</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
    <span class="n">s_axi_wvalid</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
    <span class="k">wait</span><span class="p">(</span><span class="n">s_axi_awready</span> <span class="o">&amp;&amp;</span> <span class="n">s_axi_wready</span><span class="p">);</span>

    <span class="p">@(</span><span class="k">posedge</span> <span class="n">s_axi_aclk</span><span class="p">)</span> <span class="p">#</span><span class="mh">1</span><span class="p">;</span>
    <span class="n">s_axi_awvalid</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
    <span class="n">s_axi_wvalid</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
  <span class="k">end</span>
<span class="k">endtask</span>
</pre></div><figcaption><span>Writing a word to the AXI4-Lite bus. </span></figcaption> </figure> <p>As a final note, be aware that these tasks are not at all intended to verify the protocol-level implementation of the AXI interface itself. A verified boilerplate solution, such as the one auto-generated by the Xilinx tools, would be used most of the time anyway. However, it might be interesting to know that ARM offers a set of <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0534b/DUI0534B_amba_4_axi4_protocol_assertions_ug.pdf">AXI 4 Protocol Assertion</a> cores that can be inserted into the design to verify that the bus signalling conforms to the specification.</p> <footer> Like what you read? <a href="http://twitter.com/?status=@dnadlinger:">Let me know</a> what you think or <a href="http://twitter.com/?status=Just read »Testing Verilog AXI4-Lite Peripherals« by @dnadlinger: http://klickverbot.at/blog/2016/01/testing-verilog-axi4-lite-peripherals/">share the article</a> on Twitter. </footer> </div> </article> </div> <footer id=main_footer> <ul> <li><a class=twitter href="//twitter.com/dnadlinger">Follow me on Twitter</a></li> <li><a class=mail href="/about">Contact me</a></li> <li><a class=rss href="/blog/atom.xml">Blog feed</a></li> </ul> </footer> </body> </html>